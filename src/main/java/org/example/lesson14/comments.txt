// Аннотация необходима из-за возможной параметризации классом ServiceEvent
@JsonIgnoreProperties(ignoreUnknown = true)
-- В данном случае класс ServiceEvent находится в сторонней библиотеке и имеет getter, из-за которого появляется лишнее
-- поле при сериализации, поэтому установили необходимую аннотацию, но так как в аналогичных случаях она ни разу
-- не присутствовала, то добавили комментарий чтобы избежать дальнейшего копипаста




// Вызов сборщика делается из-за большой нагрузки как очень вынужденная мера и ждет рефакторинга,
// просьба обратить внимание при создании аналогичных сервисов
System.gc();
-- Комментарий добавлен чтобы привлечь внимание разработчиков к моменту вызова в этом методе сборщика и объяснить причину




// В данном случае Lazy выбран из-за большого кол-ва связей в таблице, которая скоро будет переработана
@ManyToOne(fetch = FetchType.LAZY, mappedBy = "user")
-- Бд требовала нормализации из-за чего были добавлены временные решения и комментарии к ним




// Тип опреции определяется по коду только в рамках этой функциональности, в остальных случаях
// просьба определять операцию по признакам
private static final String TT1725 = "1725";
-- Одна из функциональностей сильно отличалась по требованиям от похожих ситуаций в приложении
-- из-за чего был добавлен объясняющий комментарий




// Для задания ссылки в конструкторе передавайте только путь
Sender(String path) {}
-- Комментарий для уточнения переданного аргумента




// При использовании данного класса не забудьте добавить необходимые конфигурации в application (читать документацию)
public class CustomListener {}
-- Лишнее напоминание в написанной библиотеке, документация и преписка о ней появилась чуть позже




// Метод является заменой старого варианта для определения типа доставки isSeaShipment()
public boolean isSelfWithBarrel() {}
-- Аналитика потребовала больших изменений и полностью переработались требования к доставке, из-за чего изменились
-- условия и названия методов, комментарий помогает разработчикам ориентироваться




//Если конец опер дня наступил, то не выполняем проверку
if (now.after(operTime) && holidays.contains(now.getLocalDate())) {}
-
if (isOperDayEnded(now)) {}




// Создания задания в scheduler
String operUid = Event.getOperUid();
validate(operUid);
scheduler.start(operUid);
-
private void schedulerStartJob() {}




// Вызов сервиса ответа Астл
stateService.save(operUid);
AstlWebClient.call(operUid);
-
private void callAstlAnswer() {}




// Если eventType c признаком удаления, то заполняем значение
if(Service.eventType().equals(EventType.DELETE) && Service.deleteDate != null) {}
-
if(deleteEvent(Service.eventType())) {}




//